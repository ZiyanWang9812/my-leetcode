# 代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素，977. 有序数组的平方

## 704 Binary search

题目链接: [704](https://leetcode.cn/problems/binary-search/description/)

**解题思路**

这是一道很典型的二分法，即把数组一分为二，如果target在左边，就往左边找。如果target在右边，就往右边找。
目前掌握的方法是左闭右闭
1. 先定义一个左边和右边的区间
   `left = 0`
   `right = len(nums) - 1`
2. 再用while loop
3. 寻找中间值 `middle = (right + left)//2`
4. 如果target在middle值的左边，就缩小左边的范围（在左边接着查找）
5. 如果target在middle值的右边，就缩小右边的范围（在右边接着查找）
6. 找到的话return middle （即index）
7. 没有找到就return -1

**遇到的难点**

第一点：区间问题

while loop是（left < right) 还是 (left <= right)。
因为是左闭右闭的区间，所以我们选择(left <= right)

第二点：middle怎么得到

假设`nums = [0, 1, 2, 3, 4, 5, 6, 7, 8] `
1. `mid = (right - left) // 2`
   这个是错误的写法，因为如果right是8，left是4，那么（8-4）/2 = 2 但是我们要的中间的index其实是5
3. `mid = (right + left) // 2` 我刚开始的写法是这个，这个在leetcode是可以运行的，但是会发生overflow。大多情况下是正确的，但是处理较大的数字时会导致overflow。
   如果left = 2,000,000,000 right = 2,000,000,000。 那么两个相加就会超过2^32的数字，导致最后middle是错误的值
5. `mid = left + (right - left) // 2` 这个方式可以正确的避免overflow。因为首先计算（right - left)，再相加就不会溢出。

第三点：target和middle值比较

刚开始的bug是我直接把target和middle值比较，即`if target > middle`，发生错误。因为target是一个数字，然而middle是index。正确的比较应该是：`if target > nums[middle]`

第四点：left 和 right的更新

我刚开始写成 `left = middle`和`right = middle`。这个是错误的。因为如果target > nums[middle] 那么表示target不等于中间值，left可以往右边挪一位。所以应该`left = middle + 1` （target在左区间，所以[left, middle - 1]）

代码实现：
```python
def search(self, nums, target):

    """
    :type nums: List[int]
    :type target: int
    :rtype: int
    """
    
    left = 0
    right = len(nums)-1
    
    while (left <= right):
        middle = left + (right - left) // 2
        if target > nums[middle]:
            left = middle + 1
        elif target < nums[middle]:
            right = middle - 1
        else:
            return middle
    return -1
```
# 27
```python
def removeElement(self, nums, val):
    """
    :type nums: List[int]
    :type val: int
    :rtype: int
    """
    slow = 0
    fast = 0
    size = len(nums)
    for fast in range(len(nums)):
        if nums[fast] != val:
            nums[slow] = nums[fast]
            slow += 1
    return slow
```
    
977 code

```python
def sortedSquares(self, nums):
    """
    :type nums: List[int]
    :rtype: List[int]
    """
    left = 0
    right = len(nums) - 1
    pos = len(nums) - 1
    results = [0] * len(nums)
    while left <= right:
        if nums[left] * nums[left] < nums[right] * nums[right]:
            results[pos] = nums[right] * nums[right]
            right -= 1
        else:
            results[pos] = nums[left] * nums[left]
            left += 1
        pos -= 1
    return results
```
